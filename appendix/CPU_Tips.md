## CPU 実装 Tips 集


本節では、 CPU エミュレータ実装の上でのハマりどころを解説します。筆者が参考文献の通りに実装してみたものの、なぜか先人が出しているトレースログと合わなかったり、概念の理解に手間取った箇所などが含まれます。  
上記の性質上、必ずしも情報が正しいとは限りません。しかし、このような実装をすることで先人が用意してくれた nestest.nes の実行ログと同様の挙動を実現することが可能かつ、マ〇オをそれなりに動作させることが可能であることがわかっています。


### ページクロス って何？

NES on FPGA などの参考文献を読んでいると、 ページクロス という概念が現れますが、これがなんなのかよくわからない、という問題です。  
NesDev Wiki によると、 6502 CPU(NES の CPU) のページサイズは 256 byte のようです。 NES のメモリは 256 byte ごとの ページ という単位で区切られ、アドレッシング操作によってこの ページ を跨いだときに ページクロス となるようです。この判定を アドレッシングモード Absolute X の命令について行うと以下のようなコードになります。


```
else if (mode == AddressingMode::AbsoluteX)
{
    uint16_t upper = 0;
    uint16_t lower = 0;
    lower = m_pCpuBus->ReadByte(PC + 1);
    upper = m_pCpuBus->ReadByte(PC + 2);

    uint16_t addr = 0;
    addr |= lower;
    addr |= (upper << 8);

    uint16_t beforeAddr = addr;
    addr += X;

    *pOutAddr = addr;
    // ページクロスで +1 クロック
    if ((beforeAddr & 0xFF00) != (addr & 0xFF00))
    {
        *pOutAdditionalCyc = 1;
    }
}
```


注目すべきは X を足す前のアドレスを beforeAddr、足した後のアドレスを addr} として、 (beforeAddr & 0xFF00) != (addr & 0xFF00) ならばページクロスとしている箇所です。  
ページサイズは 256 byte ですから、2 byte のアドレスのうち上位 1 byte が同じならば同一ページと言えます。(1 byte は 0 - 255 の 256 通りの値を取り、下位 1 byte の値で1ページ分のアドレスになることに注意してください)以上より、このような判定式でページクロスが判定できる、と言えるのです。


### B フラグの挙動


ステータスレジスタ(Pレジスタの) 4 bit 目と 5 bit 目は B フラグといって、スタックに転送された時のみ有効な bit です。これらは実際にはレジスタの値ではなく、愚直に読み書きを実装すると、 nestest.nes 等のログを比較した時に想定のログと結果が異なる、ということになります。命令 PLP の時に P レジスタに相当する変数の 4 bit 目と 5 bit 目に書き込み、 PHP の時にその値スタックに書き込む、といった実装は誤りです。  
IRQ、NMI、BRK の3つの割り込みと命令 PHP によって P レジスタの値がスタックにプッシュされますが、それぞれの場合において、プッシュされる値の 5 bit 目と 4 bit 目は以下のように設定されます。

| 割り込み or 命令 | 5bit目と4bit目の値 |
| ---- |---- |
|PHP| 11 | 
|BRK| 11 | 
|IRQ| 10 | 
|NMI| 10 | 


割り込み の節で確認した通り、 IRQ と BRK は同じアドレスの割り込みルーチンにジャンプすることになるので、割り込みルーチンはスタックにプッシュされた P レジスタの 4 bit 目の値を見てこの割り込みが IRQ なのか BRK なのかを判別することになります。  
また、PLP 命令と RTI 命令ではスタックから P レジスタの値を書き戻すことになりますが、この時も 4 bit 目と 5 bit 目を除いた bit を書き戻すことに注意が必要です。(まあ、書き込んでしまって IRQ、NMI、BRK、PHPの時に正しい値で上書きするのでも別にバレないのですが……)  
私はこのように B_FLAG_MASK (定数 0b00110000 です)のようなビットマスクを用意して、 PHP の時は立てる、 PLP の時はそのビットを更新しない といった実装にしています。  
紙面では省略していますが、スタックポインタを操作しつつ値を追加/取り出しができる PushStack PopStack などのヘルパー関数を用意していることも確認しておきましょう。こうすることでスタック関連の実装を共通化でき、実装が楽になります。


```
// 略 (Cpu::Run() の switch 文の中です)
case Opcode::PHP:
{
    // http://wiki.nesdev.com/w/index.php/Status_flags: P の 4 bit 目と 5 bit 目を立ててスタックにプッシュ
    PushStack(P | B_FLAG_MASK);
    PC += inst.m_Bytes;
    return inst.m_Cycles;
}
// 略
case Opcode::PLP:
{
    uint8_t res = PopStack();

    // http://wiki.nesdev.com/w/index.php/Status_flags: Pの 4 bit 目と 5 bit 目は更新しない
    P = (res & ~B_FLAG_MASK) | (P & B_FLAG_MASK);

    PC += inst.m_Bytes;
    return inst.m_Cycles;
}
```


出典: http://wiki.nesdev.com/w/index.php/Status_flags


### 起動時の SP の値が $FD になっているのはなぜ？


RESET 割り込みはスタックに値を書き込まないが、それはバスを write ではなく read にしているためで、通常の割り込み同様スタックにリターンアドレスと P レジスタの値を push する操作は行われ、スタックポインタはズレていきます。


### ADC のオーバーフローフラグの計算方法がわからない


筆者の参考実装では、符号付き整数のオーバーフロー検出のロジックは以下のようになっています。  
なぜこのような実装で8 bit 符号付き整数のオーバーフローを検出できるのでしょうか？


```
// M, N を 8 bit 符号付き整数、 C をキャリーフラグとしたとき、N + M + C がオーバーフローするか？
// 符号付き整数の加減算オーバーフロー判定だが、引数は uint8_tであることに注意する(符号付き整数のオーバーフローは未定義)
bool isSignedOverFlowed(uint8_t N, uint8_t M, bool C)
{
    uint8_t res = N + M + C;
    return ((M ^ res) & (N ^ res) & 0x80) == 0x80;
}
```


8 bit 符号付き整数の足し算がオーバーフローするのは以下のような条件の時です。二進数の加算を考えていることに注意してください。

 * 正 + 正だが、6 bit 目(0-indexed)からのキャリー(繰り上がり)があり、負になってしまう。
 * 負 + 負だが、符号 bit の加算で符号 bit がキャリーアウトしてしまい、 6 bit 目からのキャリーはなく、正になってしまう。



これらを同時に判定できるロジックを考えてみましょう。  
以下、変数 X の Y bit 目(0-indexed) をXY と表記します。変数 M の 7 bit 目は M7 になります。  
res = N + M + C (C は直前の計算結果のキャリー)のオーバーフローを判定することを考えます。  
負数は2の補数表現で表されますので、8 bit 整数 X が負である、とは X7 が 1 であるということです。  

```
M(>0) + N(>0) + C = res(<0) ⇔ M7 == 0 && N7 == 0 && res7 == 1
M(<0) + N(<0) + C = res(>0) ⇔ M7 == 1 && N7 == 1 && res7 == 0
```


つまり、上記のようになります。  

```
((M ^ res) & (N ^ res) & 0x80) == 0x80;
```


この式を見ると、M7 と res7 の値が異なる かつ N7 と res7 の値が異なる ならばオーバーフローと言えますので、上記の式でオーバーフローを判定することができるのです。


### SBC のオーバーフローフラグの計算方法がわからない


符号付き整数の引き算は簡単な計算で加算に帰着することができます。  
ただし、桁借り(繰り下がり)が発生した時は borrow bit が設定され、これは carry flag を反転させたものであることに注意します。  
実際に M - N - B (B は borrow bit で 0 or 1)の式変形をしてみましょう。


```
M - N - B                 元の式
M - N - B + 256           8 bit なので、 256 を足しても結果は変わらない
M - N - (1 - C) + 256     Borrow flag は Carry Flag の反転
M + (255 - N) + C         式を整理
M + ~(N) + C              255-N は、Nの1の補数であり、これはNをビット反転させたものと同じである
```


よって、 N と Borrow bit を引く代わりに、ビット反転した N を足し carry flag を足すことで足し算に帰着することができました。